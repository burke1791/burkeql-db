<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="canonical" href="https://burke1791.github.io/burkeql-db/05-selecting-data/03-buffer-pool/" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>Buffer Pool - BurkeQL Tutorial</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Buffer Pool";
        var mkdocs_page_input_path = "05-selecting-data/03-buffer-pool.md";
        var mkdocs_page_url = "/burkeql-db/05-selecting-data/03-buffer-pool/";
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> BurkeQL Tutorial
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">Home</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../00-intro/project-plan/">Project Roadmap</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">1. Basic CLI</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../01-basic-cli/intro/">Intro</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../01-basic-cli/flex/">Flex</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../01-basic-cli/bison/">Bison</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../01-basic-cli/putting-it-together/">Putting It Together</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">2. Abstract Syntax Trees</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../02-ast/intro/">Intro</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../02-ast/ast-interface/">AST Interface</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../02-ast/ast-implementation/">AST Implementation</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../02-ast/parser-refactor/">Parser Refactor</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../02-ast/parser-interface/">Parser Interface</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../02-ast/putting-it-together/">Putting It Together</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">3. The Database Page</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../03-db-page/page-structure/">Page Structure</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">4. Data Persistence</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../04-data-persistence/01-intro/">Intro</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../04-data-persistence/02-config-file/">Config File</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../04-data-persistence/03-loading-config/">Loading Config</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../04-data-persistence/04-file-interface/">DB File Interface</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../04-data-persistence/05-page-interface/">DB Page Interface</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../04-data-persistence/06-page-implementation/">DB Page Implementation</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../04-data-persistence/07-parser-refactor-insert/">Parser Refactor - Insert</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../04-data-persistence/08-serializing-and-inserting-data/">Serializing and Inserting Data</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">5. Selecting Data</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="../01-parser-refactor-select/">Parser Refactor - Select</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../02-the-sql-analyzer/">The SQL Analyzer</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="#">Buffer Pool</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#what-is-a-buffer-pool">What is a Buffer Pool?</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#buffer-pool-header">Buffer Pool Header</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#buffer-pool-implementation">Buffer Pool Implementation</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#removing-old-code">Removing Old Code</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#updating-main">Updating Main</a>
    </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../04-table-scan/">Table Scan</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../05-displaying-results/">Displaying Results</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">6. Data Types: Ints</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../06-data-types-ints/01-hard-coded-table-refactor/">Hard-Coded Table Refactor</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../06-data-types-ints/02-parser-refactor/">Parser Refactor</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../06-data-types-ints/03-fill-and-defill/">Fill and Defill</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../06-data-types-ints/04-select-updates/">Select Updates</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">7. Data Types: Bool</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../07-data-types-bool/01-hard-coded-table-refactor/">Hard-Coded Table Refactor</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../07-data-types-bool/02-parser-refactor/">Parser Refactor</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../07-data-types-bool/03-fill-and-defill/">Fill and Defill</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../07-data-types-bool/04-select-updates/">Select Updates</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">8. Data Types: Varchar</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../08-data-types-varchar/01-intro/">Intro</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../08-data-types-varchar/02-storage-and-fill/">Storage and Fill</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../08-data-types-varchar/03-temporary-code-refactor/">Temporary Code Refactor</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../08-data-types-varchar/04-inserting-data/">Inserting Data</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../08-data-types-varchar/05-defill-and-display/">Defill and Display</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">9. Data Constraint: NULL</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../09-data-constraint-null/01-intro/">Intro</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../09-data-constraint-null/02-parser-refactor/">Parser Refactor</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../09-data-constraint-null/03-writing-data/">Writing Data</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../09-data-constraint-null/04-reading-data/">Reading Data</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">BurkeQL Tutorial</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" aria-label="Docs"></a></li>
          <li class="breadcrumb-item">5. Selecting Data</li>
      <li class="breadcrumb-item active">Buffer Pool</li>
    <li class="wy-breadcrumbs-aside">
          <a href="https://github.com/burke1791/burkeql-db/edit/master/docs/05-selecting-data/03-buffer-pool.md" class="icon icon-github"> Edit on GitHub</a>
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="buffer-pool">Buffer Pool</h1>
<p>Before we go too far in implementing a simple query engine, we need to refactor how our program is able to interact with pages on disk. Right now, we only allow a single data page, so it's easy to pull it into memory at the beginning of the program, pass it around to any systems that need it, then flush to disk at the end.</p>
<p>This won't work when we support multiple pages, and by then we'll have written a lot more code that works with pages so refactoring is best done early. We're going to create a mini buffer pool.</p>
<h2 id="what-is-a-buffer-pool">What is a Buffer Pool?</h2>
<p>Relational databases are built to store and work with huge amounts of data. In such situations, the amound of data they store will far exceed the amount of memory they're given by the host machine. So in order to read and write to a lot of data pages while working within its memory constraints, they keep data pages in something called a buffer pool.</p>
<p>A buffer pool is a shared pool of memory that keeps track of all data pages currently in memory. If some process needs to read or write from a specific data page, it will ask the buffer pool for the page. If the page is currently in memory, the buffer pool returns a pointer to the data page quick and easy. If the page is not currently in memory, the buffer pool must first determine if it has enough space to house a new page. If there is enough space, then it'll pull the page from disk into memory and return a pointer to the page. If the buffer pool does not have enough space, it need to choose a page to evict from the pool before it can read the requested page into memory.</p>
<p>At present, our needs are not that complex, so we can get away with writing a really dumb buffer pool. But it is a solid starting point, and a good way to keep data file/page access constrained to a single subsystem. </p>
<h2 id="buffer-pool-header">Buffer Pool Header</h2>
<p><code>src/include/buffer/bufpool.h</code></p>
<pre><code class="language-c">typedef struct BufPoolSlot {
  uint32_t pageId;
  Page pg;
} BufPoolSlot;

typedef struct BufPool {
  FileDesc* fdesc;
  int size;
  uint32_t nextPageId;
  BufPoolSlot* slots;
} BufPool;
</code></pre>
<p>First we need two structs: one for the buffer pool itself and another for the page slots in the buffer pool. The <code>BufPool</code> struct will be responsible for reading and writing data for a single file only, hence the <code>FileDesc</code> pointer we store in it. It also has a fixed size, which corresponds to the number of slots we allow in the buffer pool - the <code>slots</code> property is an array of <code>BufPoolSlot</code>s. The <code>nextPageId</code> property tells us what <code>pageId</code> to set for any newly created pages.</p>
<p>The <code>BufPoolSlot</code> struct represents a single page in memory. When occupied, we set the <code>pageId</code> to whatever page is currently in the slot. If the slot is empty, we set <code>pageId</code> to 0.</p>
<pre><code class="language-c">BufPool* bufpool_init(FileDesc* fdesc, int numSlots);
void bufpool_destroy(BufPool* bp);

BufPoolSlot* bufpool_read_page(BufPool* bp, uint32_t pageId);
BufPoolSlot* bufpool_new_page(BufPool* bp);
void bufpool_flush_page(BufPool* bp, uint32_t pageId);
void bufpool_flush_all(BufPool* bp);
</code></pre>
<p>Now our functions, starting with the allocate/free pair. The allocator takes a <code>numSlots</code> parameter which enforces a maximum size of the buffer pool on initialization. This is kind of a hacky way we're using to limit memory consumption of our database. In reality, the rest of the program can consume as much as it wants, we're just restricting the buffer pool.</p>
<p>The <code>bufpool_flush_page</code> and <code>bufpool_read_page</code> functions are replacements for the read/write functions we already have. But we also create <code>bufpool_new_page</code> available for any writer process that needs a new page in order to insert data - we currently only support one data page, but that will chagne soon. And finally, the <code>flush_all</code> function is what our program will call when it receives the <code>\quit</code> command to make sure we're persist any in-memory changes to disk.</p>
<h2 id="buffer-pool-implementation">Buffer Pool Implementation</h2>
<p><code>src/buffer/bufpool.c</code></p>
<pre><code class="language-c">extern Config* conf;

BufPool* bufpool_init(FileDesc* fdesc, int numSlots) {
  BufPool* bp = malloc(sizeof(BufPool));
  bp-&gt;fdesc = fdesc;
  bp-&gt;size = numSlots;
  bp-&gt;slots = calloc(numSlots, sizeof(BufPoolSlot));

  // initialize each slot with a blank page
  for (int i = 0; i &lt; numSlots; i++) {
    bp-&gt;slots[i].pg = new_page();
    bp-&gt;slots[i].pageId = 0;
  }

  int offset = lseek(fdesc-&gt;fd, -(conf-&gt;pageSize), SEEK_END);

  if (offset == -1) {
    bp-&gt;nextPageId = 1;
  } else {
    bp-&gt;nextPageId = (offset / conf-&gt;pageSize) + 1;
  }

  return bp;
}

void bufpool_destroy(BufPool* bp) {
  if (bp == NULL) return;

  if (bp-&gt;slots != NULL) {
    for (int i = 0; i &lt; bp-&gt;size; i++) {
      if (bp-&gt;slots[i].pg != NULL) free_page(bp-&gt;slots[i].pg);
    }

    free(bp-&gt;slots);
  }

  free(bp);
}
</code></pre>
<p>Starting with the allocator/free functions again. The allocator sets the <code>fdesc</code> and <code>size</code> properties according to its input parameters, then initializes the <code>slots</code> array with a number equal to <code>numSlots</code>. Then we need to initialize each of the slots with blank database pages that are available for an incoming data page being read from disk. Next, we calculate what the <code>nextPageId</code> should be based on how large the file is. Our file size will always be some multiple of the <code>conf-&gt;pageSize</code>, so the math fairly easy to do.</p>
<p>The free function, as you'd expect, loops through the slots and frees everything we allocated in the beginning.</p>
<pre><code class="language-c">BufPoolSlot* bufpool_read_page(BufPool* bp, uint32_t pageId) {
  if (pageId == 0) return NULL;
  BufPoolSlot* slot = bufpool_find_empty_slot(bp);

  if (slot == NULL) {
    // evict a page and return the empty slot
    slot = bufpool_evict_page(bp);
  }

  lseek(bp-&gt;fdesc-&gt;fd, (pageId - 1) * conf-&gt;pageSize, SEEK_SET);
  int bytes_read = read(bp-&gt;fdesc-&gt;fd, slot-&gt;pg, conf-&gt;pageSize);

  if (bytes_read != conf-&gt;pageSize) {
    printf(&quot;Bytes read: %d\n&quot;, bytes_read);
    return NULL;
  }

  slot-&gt;pageId = pageId;

  return slot;
}
</code></pre>
<p>The <code>read_page</code> function has more going on than you might expect. It first needs to find an unclaimed slot in the buffer pool, which we wrote a static helper function for (see below). If all slots are occupied, we need to evict a page by flushing it to disk - using another static helper function. After that, we'll have an empty slot we can use to read a page into.</p>
<pre><code class="language-c">static BufPoolSlot* bufpool_find_empty_slot(BufPool* bp) {
  for (int i = 0; i &lt; bp-&gt;size; i++) {
    if (bp-&gt;slots[i].pageId == 0) return &amp;bp-&gt;slots[i];
  }

  return NULL;
}

static BufPoolSlot* bufpool_evict_page(BufPool* bp) {
  // just evict the first page for now
  uint32_t pageId = bp-&gt;slots[0].pageId;
  bufpool_flush_page(bp, pageId);
  bp-&gt;slots[0].pageId = 0;
  return &amp;bp-&gt;slots[0];
}
</code></pre>
<p>These helper functions are pretty basic. In the first one, we simply loop through the <code>slots</code> array and return the first <code>pageId = 0</code> slot that we find - <code>NULL</code> otherwise. The <code>evict_page</code> function is extremely simple right now - we're just evicting the first page in the <code>slots</code> array. When we start supporting multiple pages, we'll come up with a better way to decide which page gets flushed.</p>
<pre><code class="language-c">BufPoolSlot* bufpool_new_page(BufPool* bp) {
  BufPoolSlot* slot = bufpool_find_empty_slot(bp);

  slot-&gt;pageId = bp-&gt;nextPageId;
  bp-&gt;nextPageId++;

  memset(slot-&gt;pg, 0, conf-&gt;pageSize);

  PageHeader* pgHdr = ((PageHeader*)slot-&gt;pg);
  pgHdr-&gt;pageId = slot-&gt;pageId;
  pgHdr-&gt;freeBytes = conf-&gt;pageSize - sizeof(PageHeader);
  pgHdr-&gt;freeData = conf-&gt;pageSize - sizeof(PageHeader);

  return slot;
}
</code></pre>
<p>Our new page function takes advantage of the buffer pool's <code>nextPageId</code> parameter and creates a blank page in an available slot.</p>
<pre><code class="language-c">void bufpool_flush_page(BufPool* bp, uint32_t pageId) {
  BufPoolSlot* slot = bufpool_find_slot_by_page_id(bp, pageId);

  if (slot == NULL) {
    printf(&quot;Page does not exist in the buffer pool\n&quot;);
    return;
  }

  if (!flush_page(bp-&gt;fdesc-&gt;fd, slot-&gt;pg, pageId)) {
    printf(&quot;Flush page failure\n&quot;);
    return;
  }

  slot-&gt;pageId = 0;
}
</code></pre>
<p>Next up, we have our flush page function. Given a <code>pageId</code>, it finds the slot where that page exists, then calls <code>flush_page</code> to write it to disk.</p>
<pre><code class="language-c">static BufPoolSlot* bufpool_find_slot_by_page_id(BufPool* bp, uint32_t pageId) {
  for (int i = 0; i &lt; bp-&gt;size; i++) {
    if (bp-&gt;slots[i].pageId == pageId) return &amp;bp-&gt;slots[i];
  }

  return NULL;
}

static bool flush_page(int fd, Page pg, uint32_t pageId) {
  uint32_t headerPageId = ((PageHeader*)pg)-&gt;pageId;

  if (headerPageId != pageId || pageId == 0) {
    printf(&quot;Page Ids do not match\n&quot;);
    return false;
  }

  lseek(fd, (pageId - 1) * conf-&gt;pageSize, SEEK_SET);
  int bytes_written = write(fd, pg, conf-&gt;pageSize);

  if (bytes_written != conf-&gt;pageSize) {
    printf(&quot;Bytes written: %d\n&quot;, bytes_written);
    return false;
  }

  return true;
}
</code></pre>
<p>Finding a slot by pageId is pretty simple - just loop through the slots until you find the matching pageId. The <code>flush_page</code> function is essentially the same as the one we're replacing. Move the file offset to the correct spot, then attempt to write <code>conf-&gt;pageSize</code> bytes to the file.</p>
<pre><code class="language-c">void bufpool_flush_all(BufPool* bp) {
  for (int i = 0; i &lt; bp-&gt;size; i++) {
    BufPoolSlot* slot = &amp;bp-&gt;slots[i];
    flush_page(bp-&gt;fdesc-&gt;fd, slot-&gt;pg, slot-&gt;pageId);
  }
}
</code></pre>
<p>Finally, we have our <code>flush_all</code> function. Simple loop through the <code>slots</code> array and calling <code>flush_page</code>.</p>
<h2 id="removing-old-code">Removing Old Code</h2>
<p><code>src/include/storage/page.h</code></p>
<pre><code class="language-diff">-Page read_page(int fd, uint32_t pageId);
-void flush_page(int fd, Page pg);
</code></pre>
<p>We no longer need the read and flush functions we wrote in our storage engine code.</p>
<p><code>src/storage/page.c</code></p>
<pre><code class="language-diff">-Page read_page(int fd, uint32_t pageId) {
-  Page pg = new_page();
-  lseek(fd, (pageId - 1) * conf-&gt;pageSize, SEEK_SET);
-  int bytes_read = read(fd, pg, conf-&gt;pageSize);
-
-  if (bytes_read != conf-&gt;pageSize) {
-    printf(&quot;Bytes read: %d\n&quot;, bytes_read);
-    PageHeader* pgHdr = (PageHeader*)pg;
-    /* Since this is a brand new page, we need to set the header fields appropriately */
-    pgHdr-&gt;pageId = pageId;
-    pgHdr-&gt;freeBytes = conf-&gt;pageSize - sizeof(PageHeader);
-    pgHdr-&gt;freeData = conf-&gt;pageSize - sizeof(PageHeader);
-  }
-
-  return pg;
-}
-
-void flush_page(int fd, Page pg) {
-  int pageId = ((PageHeader*)pg)-&gt;pageId;
-  lseek(fd, (pageId - 1) * conf-&gt;pageSize, SEEK_SET);
-  int bytes_written = write(fd, pg, conf-&gt;pageSize);
-
-  if (bytes_written != conf-&gt;pageSize) {
-    printf(&quot;Page flush unsuccessful\n&quot;);
-  }
-}
</code></pre>
<h2 id="updating-main">Updating Main</h2>
<p><code>src/main.c</code></p>
<pre><code class="language-diff"> /* TEMPORARY CODE SECTION */

 #define RECORD_LEN  36  // 12-byte header + 4-byte Int + 20-byte Char(20)
+#define BUFPOOL_SLOTS  1
</code></pre>
<p>First we add a new macro so we can control how many buffer pool slots we want to allow. Start with one for now since our database can only work with one page anyways.</p>
<pre><code class="language-diff">-static bool insert_record(Page pg, int32_t person_id, char* name) {
+static bool insert_record(BufPool* bp, int32_t person_id, char* name) {
+  BufPoolSlot* slot = bufpool_read_page(bp, 1);
+  if (slot == NULL) slot = bufpool_new_page(bp);
   RecordDescriptor* rd = construct_record_descriptor();
   Record r = record_init(RECORD_LEN);
   serialize_data(rd, r, person_id, name);
-  bool insertSuccessful = page_insert(pg, r, RECORD_LEN);
+  bool insertSuccessful = page_insert(slot-&gt;pg, r, RECORD_LEN);

   free_record_desc(rd);
   free(r);

   return insertSuccessful;
 }
</code></pre>
<p>Instead of passing a <code>Page</code> around everywhere, we're going to start passing around a pointer to the <code>BufPool</code>.</p>
<pre><code class="language-diff"> int main(int argc, char** argv) {
   // initialize global config
   conf = new_config();

   if (!set_global_config(conf)) {
     return EXIT_FAILURE;
   }

   // print config
   print_config(conf);

   FileDesc* fdesc = file_open(conf-&gt;dataFile);
-  Page pg = read_page(fdesc-&gt;fd, 1);
+  BufPool* bp = bufpool_init(fdesc, BUFPOOL_SLOTS);

   while(true) {
     print_prompt();
     Node* n = parse_sql();

     if (n == NULL) continue;

     print_node(n);

     switch (n-&gt;type) {
       case T_SysCmd:
         if (strcmp(((SysCmd*)n)-&gt;cmd, &quot;quit&quot;) == 0) {
           free_node(n);
           printf(&quot;Shutting down...\n&quot;);
-          flush_page(fdesc-&gt;fd, pg);
-          free_page(pg);
+          bufpool_flush_all(bp);
+          bufpool_destroy(bp);
           file_close(fdesc);
           return EXIT_SUCCESS;
         }
         break;
       case T_InsertStmt:
         int32_t person_id = ((InsertStmt*)n)-&gt;personId;
         char* name = ((InsertStmt*)n)-&gt;name;
-        if (!insert_record(pg, person_id, name)) {
+        if (!insert_record(bp, person_id, name)) {
           printf(&quot;Unable to insert record\n&quot;);
         }
         break;
       case T_SelectStmt:
         if (!analyze_node(n)) {
           printf(&quot;Semantic analysis failed\n&quot;);
         }
         break;
     }

     free_node(n);
   }

   return EXIT_SUCCESS;
 }
</code></pre>
<p>First thought here: our main function is getting too big, we'll need to fix that. Second, we just have a few updates to make sure we're passing around a <code>BufPool</code> pointer instead of a <code>Page</code>.</p>
<p><code>src/Makefile</code></p>
<pre><code class="language-diff">SRC_FILES = main.c \
            parser/parse.c \
            parser/parsetree.c \
            global/config.c \
            storage/file.c \
            storage/page.c \
            storage/record.c \
+           storage/datum.c \
+           buffer/bufpool.c
</code></pre>
<p>The program should behave exactly the same as it did before.</p>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../02-the-sql-analyzer/" class="btn btn-neutral float-left" title="The SQL Analyzer"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../04-table-scan/" class="btn btn-neutral float-right" title="Table Scan">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
        <span>
          <a href="https://github.com/burke1791/burkeql-db/" class="fa fa-github" style="color: #fcfcfc"> GitHub</a>
        </span>
    
    
      <span><a href="../02-the-sql-analyzer/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../04-table-scan/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../..";</script>
    <script src="../../js/theme_extra.js"></script>
    <script src="../../js/theme.js"></script>
      <script src="../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
